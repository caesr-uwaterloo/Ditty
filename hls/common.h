#pragma once
#ifndef __VITIS_SYSTEM_COMMON_H_
#define __VITIS_SYSTEM_COMMON_H_
#include <ap_int.h>
#include <hls_stream.h>
#include <iostream>
#include "constants.h"
#include "addr_map.h"

// MSI Protocol
#ifndef GP
#include "MSIProtocol_states.h"
#else
#include "GPMSIProtocol_states.h"
#endif

// NOTE: this file would be automatically generated by a python script
// This is because complicated constexpr are not supported


#ifdef __SYNTHESIS__
#define INSTANCE_SPECIFIC_VAR(decl) decl
#define _acc(var) var
#else
// Fall back to a generic implementation
// #define INSTANCE_SPECIFIC_VAR(decl) decl[MAX_INST]
// #define _acc(var) var[id]
#define INSTANCE_SPECIFIC_VAR(decl) thread_local decl
#define _acc(var) var
#endif

typedef ap_uint<32> word_t;

inline addr_t to_cl_addr(addr_t addr) {
  return addr & (~(CL_SIZE - 1));
}

inline addr_t to_tag(addr_t addr) {
  return (addr >> log2c_CL_SIZE);
}

template<typename T>
struct Result {
  bool ok;
  T data;
};

struct Request {
  // 128 - 16
  cacheline_t           data;
  // 256 bit in-band data
  // when interfacing with Bmb, assuming it is 16-byte aligned
  // addr & 1 == 0 - Load
  // addr & 1 == 1 - Store
  // when interfacing with the directory
  // addr & F is the request type (e.g. GetS/GetM etc)
  // 32 - 4
  addr_t                addr;
  // 32 - 4
  // as response: 15-0 acks
  // as request : wb_addr & F is the write-back type
  addr_t                wb_addr;  // can be re-used: 15-0: acks

  // 2-bit should be enough for us to handle network ids
  // 31: is_to_directory
  // 13 - 8: respond_to
  // 7 - 2: src
  // 1 - 0: network id
  ap_uint<32>           respond_to__src__network_id;


  // 64 bit out-of-band data

  // machine_destination_t should be 32-bit number
  // we will strip this field out and replace it with router destination
  // in hardware
  machine_destination_t dst;
  // src, dst, network_id

  // we always have a size of whole cache line
  // req_size_t            sz;
  // request_t             type_;
  // request_t             wb_type_;
  // ap_uint<log2c_NWAY>   way;
  // target_t              src;
  // machine_destination_t dst;   // could be broadcasted
  // target_t              respond_to;   // send response to if necessary
  // ack_t                 acks;  // determine the number of acks we should expect
  // atomic_op_t           atomic_op; // atomic operations from the core
  // bool                  is_exclusive = false; // exclusive copy
  // bool                  is_combined = false; // exclusive copy
  // acquire/release

#ifndef __SYNTHESIS__

  friend std::ostream& operator<<(std::ostream& os, const Request& r) {
    os << "R(a=" << std::hex << (unsigned long)(r.addr) << std::dec
    << ", d=" << r.data.to_string(16) <<", type=" << (r.addr & 0xf) << ", src=" << r.respond_to__src__network_id(16, 2)
    << ", respond_to=" << r.respond_to__src__network_id(31, 17).to_string(10)
    << ", dst=" << r.dst.to_string(2)
    << ", ack=" << (r.wb_addr & 0xFF)
    << ")";
    return os;
  }
  static Request loadRequest(addr_t address) {
    assert((address & 0xf) == 0);
    Request core_request;
    core_request.addr = address | (int)LD;
    core_request.wb_addr = 0;  // not using this
    core_request.data = 0;
    core_request.respond_to__src__network_id = (0 << (2 + 15)) | (0 << 2) | CoreNetwork;
    core_request.dst = 0; // from core
    return core_request;
  }
  static Request storeRequest(addr_t address, const cacheline_t& data) {
    Request core_request;
    core_request.addr = address | (int)ST;
    core_request.data = data;
    core_request.respond_to__src__network_id = (0 << (2 + 15)) | (0 << 2) | CoreNetwork;
    core_request.dst = 0; // from core
    return core_request;
  }
#endif
}
#ifndef __SYNTHESIS__
  __attribute__((__aligned__(64)))
#endif
;

inline int get_src(Request& req) {
  return req.respond_to__src__network_id(7, 2);
}
inline void set_src(Request& req, int src) {
  req.respond_to__src__network_id(7, 2) = src;
}

inline int get_acks(Request& req) {
  return req.wb_addr(15, 0);
}

inline void set_acks(Request& req, int acks) {
  req.wb_addr(15, 0) = acks;
}

inline int get_network_id(Request& req) {
  return req.respond_to__src__network_id(1, 0);
}
inline void set_network_id(Request& req, int network_id) {
  req.respond_to__src__network_id(1, 0) = network_id;
}

inline bool is_core(Request& req) {
  return get_network_id(req) == CoreNetwork;
}
inline bool is_dir(Request& req) {
  return isDir(get_src(req));
}

inline int get_respond_to(Request& req) {
  return req.respond_to__src__network_id(13, 8);
}
inline void set_respond_to(Request& req, int respond_to) {
  req.respond_to__src__network_id(13, 8) = respond_to;
}

inline void set_to_dir(Request& req, bool is_dir) {
  req.respond_to__src__network_id(31, 31) = is_dir;
}

inline int get_to_dir(Request& req) {
  return req.respond_to__src__network_id(31, 31);
}

inline int get_type(Request& req) {
  return req.addr & 0xf;
}
inline int get_wb_type(Request& req) {
  return req.wb_addr & 0xf;
}
inline bool get_is_combined(Request& req) {
  return get_wb_type(req) != 0;
}
inline void set_type(Request& req, int type) {
  req.addr = (req.addr & ~0xf) | (type & 0xf);
}

inline void set_combined_type(Request& req, addr_t wb_addr, int type) {
  req.wb_addr = (wb_addr & 0xfffffff0) | type;
}

inline bool request_contains_cacheline(const Request& req) {
  return (req.addr & 0xf) == Data;
}

inline void set_dst(Request& req, machine_destination_t dst) {
  req.dst = dst;
}

// This struct will be packed into 256 byte any ways
struct Response {
  // 128B
  cacheline_t  data;
  // 4
  addr_t       addr;
  // 4
  ap_uint<32>  latency;
  // 8
  ap_uint<64>  wallclock;
}
#ifndef __SYNTHESIS__
  __attribute__((__aligned__(16)))
#endif
;

struct DRAMRequest {
  cacheline_t data;
  addr_t addr;

#ifndef __SYNTHESIS__

  friend std::ostream& operator<<(std::ostream& os, const DRAMRequest& r) {
    os << "DRAMRequest(addr=" << std::hex << (unsigned long)r.addr << ", data=" << r.data.to_string(16) << ")";
    return os;
  }
#endif
};

struct DRAMResponse {
  cacheline_t data;
  addr_t addr;
#ifndef __SYNTHESIS__

  friend std::ostream& operator<<(std::ostream& os, const DRAMResponse& r) {
    os << "DRAMResponse(addr=" << std::hex << (unsigned long)r.addr << ", data=" << r.data.to_string(16) << ")";
    return os;
  }
#endif
};

typedef ap_uint<ADDR_W - log2c_CL_SIZE> tag_t;
typedef ap_uint<log2c_NWAY> age_t ;
struct tag_entry_t {
  bool valid = false;
  tag_t tag = 0;
  coherence_state_t coh = 0;
  bool dirty = false;
#ifndef __SYNTHESIS__

  friend std::ostream& operator<<(std::ostream& os, const tag_entry_t& t) {
    os << "T(v=" << t.valid << ", t" << std::hex << (unsigned long)t.tag << std::dec << ", state=" << t.coh << ")";
    return os;
  }
#endif
};

struct llc_tag_t {
  // bool                  valid = false;
  coherence_state_t     coh = 0;
  tag_t                 tag = 0;
  machine_destination_t sharer;
  machine_destination_t sharer_count;
  target_t              owner;
  bool dirty = false;
#ifndef __SYNTHESIS__

  friend std::ostream& operator<<(std::ostream& os, const llc_tag_t& t) {
    os << "TAG(tag=" << std::hex << (unsigned long)t.tag << std::dec << ", state=" << t.coh << ", share=" << t.sharer.to_string(2) << ", owner=" << t.owner << ", sharer_count=" << t.sharer_count << ")";
    return os;
  }
#endif
};

inline addr_t tag_to_addr(tag_t tag) {
  return (tag << log2c_CL_SIZE);
}
inline addr_t addr_to_offset(addr_t addr) {
  return addr & (CL_SIZE - 1);
}
// NOTE: we now don't have to handle non-word based accesses
inline cacheline_t get_word_with_offset(cacheline_t data, addr_t addr) {
  return data;
}
inline cacheline_t set_word_with_offset(cacheline_t data, addr_t addr, word_t w) {
  addr_t offset = addr_to_offset(addr);
  word_t mask = -1;
  cacheline_t val = w << (offset * 8);
  cacheline_t mak = ((cacheline_t)mask) << (offset * 8);
  return (data & (~mak)) | val;
}

// for implementing log entries
struct log_entry_t {
  addr_t            addr;

  coherence_state_t state;
  event_t 	        event;
  coherence_state_t next_state;
  bool covered;

  int error_code;
};


#ifdef __DEPRECATE_VERSION
// offset is the offset from the start of the cacheline in bytes
inline cacheline_t handle_store_atomic_request(
    addr_t offset,
    atomic_op_t atm_op,
    cacheline_t cache,
    word_t word_in,
    word_t& word_out,
    req_size_t sz,
    bool is_amo
) {

  word_t mask = 0;
  word_out = 0;
  if(sz == double_word) mask = (0xFFFFFFFFFFFFFFFFUL);
  else if(sz == word) mask = (0xFFFFFFFFU);
  else if(sz == half_word) mask = (0xFFFF);
  else if(sz == byte) mask = (0xFF);
  else {
#ifndef __SYNTHESIS__
    assert(false);
#endif
  }
  offset = addr_to_offset(offset);
  cacheline_t line_mask = ((cacheline_t)mask << (offset * 8));
  if(!is_amo) {
    // store, no atomic operation
    word_t target_word = word_in & mask;
    return (cache & ~line_mask) | (cacheline_t(target_word) << (offset * 8));
  } else { // is_amo == true
    // target_word is the input word to impose on the old value
    word_t target_word = word_in & mask;
    // word_out is the old value
    word_out = get_word_with_offset(cache, offset) & mask;
    if(atm_op == amoadd) {
      target_word += word_out;
    } else if(atm_op == amoxor) {
      target_word ^= word_out;
    } else if(atm_op == amoand) {
      target_word &= word_out;
    } else if(atm_op == amoor) {
      target_word |= word_out;
    } else if(atm_op == amomin) {
      if(sz == word) {
        ap_int<32> tw = target_word;
        ap_int<32> wo = word_out;
        target_word = tw < wo ? tw : wo;
      } else {
        ap_int<64> tw = target_word;
        ap_int<64> wo = word_out;
        target_word = tw < wo ? tw : wo;
      }
    } else if(atm_op == amomax) {
      if(sz == word) {
        ap_int<32> tw = target_word;
        ap_int<32> wo = word_out;
        target_word = tw < wo ? wo : tw;
      } else {
        ap_int<64> tw = target_word;
        ap_int<64> wo = word_out;
        target_word = tw < wo ? wo : tw;
      }
    } else if(atm_op == amominu) {
      target_word = target_word < word_out ? target_word : word_out;
    } else if(atm_op == amomaxu) {
      target_word = target_word < word_out ? word_out : target_word;
    }
    return (cache & ~line_mask) | (cacheline_t(target_word) << (offset * 8));
  }
}
#endif

template<typename T>
void flush_hls_stream(hls::stream<T>& strm) {
  while(!strm.empty()) {
    strm.read();
  }
}

#endif
